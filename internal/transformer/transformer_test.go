package transformer

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"testing"

	"github.com/jwtly10/litlua"
	"github.com/stretchr/testify/require"
)

func TestTransformer(t *testing.T) {
	tests := []struct {
		name      string
		inputFile string
		opts      TransformOptions
		wantErr   string
		validate  func(t *testing.T, outputPath string)
	}{
		{
			name:      "pretty_lua",
			inputFile: "basic.litlua.md",
			opts: TransformOptions{
				WriterMode: litlua.ModePretty,
				NoBackup:   true,
			},
			validate: func(t *testing.T, outputPath string) {
				content, err := os.ReadFile(outputPath)
				require.NoError(t, err)

				require.Contains(t, outputPath, "compiled.litlua.lua")

				require.Contains(t, string(content), "Generated by LitLua (https://www.github.com/jwtly10/litlua)")
				require.Contains(t, string(content), "local name = \"Hello World\"\nprint(name)")
				require.Contains(t, string(content), "foo = 1 + 2\nprint(foo)")
				require.Contains(t, string(content), "local a = y\nprint(a)")
				require.Contains(t, string(content), "-- Bar is a function that adds two numbers\n--\n-- @param a number\n--\n-- @param b number\n--\n-- @return number sum of a and b\nBar = function(a, b)\n    return a + b\nend\n\n-- You can go to definition of bar by clicking on it\nprint(Bar(10, 11))\n\n-- try typing B in this print function and see the completion\nprint(...)")
			},
		},
		{
			name:      "pretty_lua_with_no_litlua_ext",
			inputFile: "basic.litlua.md",
			opts: TransformOptions{
				WriterMode:        litlua.ModePretty,
				NoBackup:          true,
				NoLitLuaOutputExt: true,
			},
			validate: func(t *testing.T, outputPath string) {
				content, err := os.ReadFile(outputPath)
				require.NoError(t, err)

				require.Contains(t, outputPath, "compiled.lua")

				require.Contains(t, string(content), "Generated by LitLua (https://www.github.com/jwtly10/litlua)")
				require.Contains(t, string(content), "local name = \"Hello World\"\nprint(name)")
				require.Contains(t, string(content), "foo = 1 + 2\nprint(foo)")
				require.Contains(t, string(content), "local a = y\nprint(a)")
				require.Contains(t, string(content), "-- Bar is a function that adds two numbers\n--\n-- @param a number\n--\n-- @param b number\n--\n-- @return number sum of a and b\nBar = function(a, b)\n    return a + b\nend\n\n-- You can go to definition of bar by clicking on it\nprint(Bar(10, 11))\n\n-- try typing B in this print function and see the completion\nprint(...)")
			},
		},
		{
			name:      "shadow_lua",
			inputFile: "basic.litlua.md",
			opts: TransformOptions{
				WriterMode: litlua.ModeShadow,
				NoBackup:   true,
			},
			validate: func(t *testing.T, outputPath string) {
				content, err := os.ReadFile(outputPath)
				require.NoError(t, err)

				require.Contains(t, outputPath, "basic.litlua.lua")

				require.NotContains(t, string(content), "Generated by LitLua (https://www.github.com/jwtly10/litlua)")
				require.Contains(t, string(content), "local name = \"Hello World\"\nprint(name)")
				require.Contains(t, string(content), "foo = 1 + 2\nprint(foo)")
				require.Contains(t, string(content), "local a = y\nprint(a)")
				require.Contains(t, string(content), "-- Bar is a function that adds two numbers\n--\n-- @param a number\n--\n-- @param b number\n--\n-- @return number sum of a and b\nBar = function(a, b)\n    return a + b\nend\n\n-- You can go to definition of bar by clicking on it\nprint(Bar(10, 11))\n\n-- try typing B in this print function and see the completion\nprint(...)")
			},
		},
		{
			name:      "broken_lua_block",
			inputFile: "broken_lua_block.litlua.md",
			opts: TransformOptions{
				WriterMode:          litlua.ModePretty,
				NoBackup:            true,
				RequirePragmaOutput: false,
			},
			validate: func(t *testing.T, outputPath string) {
				content, err := os.ReadFile(outputPath)
				require.NoError(t, err)

				require.Contains(t, outputPath, "compiled.litlua.lua")

				require.Contains(t, string(content), "Generated by LitLua (https://www.github.com/jwtly10/litlua)")
				require.Contains(t, string(content), "local name = \"Hello World\"\nprint(name)<!-- @pragma output: compiled.lua -->\n\n# This file is both a real test and an example of the LSP for LitLua\n\nWe have some basic lua blocks here, which you can play around with and see the lsp complain!\n\nThis works... try to break it\n\nlocal name = \"Hello World\"\nprint(name)")
			},
		},
		{
			name:      "with_pragma",
			inputFile: "with_pragma.litlua.md",
			opts: TransformOptions{
				WriterMode:          litlua.ModePretty,
				NoBackup:            true,
				RequirePragmaOutput: true,
			},
			validate: func(t *testing.T, outputPath string) {
				content, err := os.ReadFile(outputPath)
				require.NoError(t, err)

				require.Contains(t, outputPath, "compiled.litlua.lua")

				require.Contains(t, string(content), "Generated by LitLua (https://www.github.com/jwtly10/litlua)")
				require.Contains(t, string(content), "local name = \"Hello World\"\nprint(name)")
				require.Contains(t, string(content), "foo = 1 + 2\nprint(foo)")
				require.Contains(t, string(content), "local a = y\nprint(a)")
				require.Contains(t, string(content), "-- Bar is a function that adds two numbers\n--\n-- @param a number\n--\n-- @param b number\n--\n-- @return number sum of a and b\nBar = function(a, b)\n    return a + b\nend\n\n-- You can go to definition of bar by clicking on it\nprint(Bar(10, 11))\n\n-- try typing B in this print function and see the completion\nprint(...)")
			},
		},
		{
			name:      "with_invalid_output_pragma_pretty",
			inputFile: "with_invalid_output_pragma.litlua.md",
			opts: TransformOptions{
				WriterMode:          litlua.ModePretty,
				NoBackup:            true,
				RequirePragmaOutput: true,
			},
			validate: func(t *testing.T, outputPath string) {
				content, err := os.ReadFile(outputPath)
				require.NoError(t, err)

				// Ensure the output file is .lua, even if pragma is not
				require.Contains(t, outputPath, "compiled.invalid.litlua.lua")

				require.Contains(t, string(content), "Generated by LitLua (https://www.github.com/jwtly10/litlua)")
				require.Contains(t, string(content), "local name = \"Hello World\"\nprint(name)")
				require.Contains(t, string(content), "foo = 1 + 2\nprint(foo)")
				require.Contains(t, string(content), "local a = y\nprint(a)")
				require.Contains(t, string(content), "-- Bar is a function that adds two numbers\n--\n-- @param a number\n--\n-- @param b number\n--\n-- @return number sum of a and b\nBar = function(a, b)\n    return a + b\nend\n\n-- You can go to definition of bar by clicking on it\nprint(Bar(10, 11))\n\n-- try typing B in this print function and see the completion\nprint(...)")
			},
		},
		{
			name:      "with_invalid_output_pragma_shadow",
			inputFile: "with_invalid_output_pragma.litlua.md",
			opts: TransformOptions{
				WriterMode:          litlua.ModeShadow,
				NoBackup:            true,
				RequirePragmaOutput: false,
			},
			validate: func(t *testing.T, outputPath string) {
				content, err := os.ReadFile(outputPath)
				require.NoError(t, err)

				// Ensure the output file is LUA
				require.Contains(t, outputPath, "with_invalid_output_pragma.litlua.lua")

				require.NotContains(t, string(content), "Generated by LitLua (https://www.github.com/jwtly10/litlua)")
				require.Contains(t, string(content), "local name = \"Hello World\"\nprint(name)")
				require.Contains(t, string(content), "foo = 1 + 2\nprint(foo)")
				require.Contains(t, string(content), "local a = y\nprint(a)")
				require.Contains(t, string(content), "-- Bar is a function that adds two numbers\n--\n-- @param a number\n--\n-- @param b number\n--\n-- @return number sum of a and b\nBar = function(a, b)\n    return a + b\nend\n\n-- You can go to definition of bar by clicking on it\nprint(Bar(10, 11))\n\n-- try typing B in this print function and see the completion\nprint(...)")
			},
		},
		{
			name:      "without_output_pragma",
			inputFile: "without_output_pragma.litlua.md",
			opts: TransformOptions{
				WriterMode:          litlua.ModePretty,
				NoBackup:            true,
				RequirePragmaOutput: true,
			},
			validate: func(t *testing.T, outputPath string) {
				content, err := os.ReadFile(outputPath)
				require.NoError(t, err)

				require.Contains(t, string(content), "Generated by LitLua (https://www.github.com/jwtly10/litlua)")
				require.Contains(t, string(content), "local name = \"Hello World\"\nprint(name)")
				require.Contains(t, string(content), "foo = 1 + 2\nprint(foo)")
				require.Contains(t, string(content), "local a = y\nprint(a)")
				require.Contains(t, string(content), "-- Bar is a function that adds two numbers\n--\n-- @param a number\n--\n-- @param b number\n--\n-- @return number sum of a and b\nBar = function(a, b)\n    return a + b\nend\n\n-- You can go to definition of bar by clicking on it\nprint(Bar(10, 11))\n\n-- try typing B in this print function and see the completion\nprint(...)")
			},
			wantErr: "pragma key 'output' is required for transformation",
		},
		{
			name:      "without_output_pragma_but_not_required",
			inputFile: "without_output_pragma.litlua.md",
			opts: TransformOptions{
				WriterMode:          litlua.ModePretty,
				NoBackup:            true,
				RequirePragmaOutput: false,
			},
			validate: func(t *testing.T, outputPath string) {
				content, err := os.ReadFile(outputPath)
				require.NoError(t, err)

				require.Contains(t, outputPath, "without_output_pragma.litlua.lua")

				require.Contains(t, string(content), "Generated by LitLua (https://www.github.com/jwtly10/litlua)")
				require.Contains(t, string(content), "local name = \"Hello World\"\nprint(name)")
				require.Contains(t, string(content), "foo = 1 + 2\nprint(foo)")
				require.Contains(t, string(content), "local a = y\nprint(a)")
				require.Contains(t, string(content), "-- Bar is a function that adds two numbers\n--\n-- @param a number\n--\n-- @param b number\n--\n-- @return number sum of a and b\nBar = function(a, b)\n    return a + b\nend\n\n-- You can go to definition of bar by clicking on it\nprint(Bar(10, 11))\n\n-- try typing B in this print function and see the completion\nprint(...)")
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dir := newTestDir(t)
			defer dir.cleanup()

			testInputDir := filepath.Join("testdata", "transformer")
			input, err := os.ReadFile(filepath.Join(testInputDir, tt.inputFile))
			require.NoError(t, err)

			setupFiles(t, testInputDir, dir)

			transformer := NewTransformer(tt.opts)

			mdPath := filepath.Join(dir.path, tt.inputFile)
			err = os.WriteFile(mdPath, input, 0644)
			require.NoError(t, err)

			src := MarkdownSource{
				Content: bytes.NewReader(input),
				Metadata: litlua.MetaData{
					AbsSource: mdPath,
				},
			}

			if tt.opts.WriterMode == litlua.ModeShadow {
				shadowPath := filepath.Join(dir.path, transformer.CleanShadowOutputExt(tt.inputFile))
				src.Metadata.AbsSource = shadowPath

				outputPath, err := transformer.TransformToPath(src, shadowPath)
				if tt.wantErr != "" {
					if err == nil {
						t.Fatalf("expected error: %s, got nil", tt.wantErr)
					}
					require.Equal(t, tt.wantErr, err.Error())
					return
				}
				require.NoError(t, err)

				fmt.Printf("output path: %s", outputPath)

				tt.validate(t, outputPath)
				return
			}

			outputPath, err := transformer.Transform(src)
			if tt.wantErr != "" {
				if err == nil {
					t.Fatalf("expected error: %s, got nil", tt.wantErr)
				}
				require.Equal(t, tt.wantErr, err.Error())
				return
			}
			require.NoError(t, err)

			fmt.Printf("output path: %s", outputPath)

			tt.validate(t, outputPath)
		})
	}
}

func TestCleanPragmaOutputExt(t *testing.T) {
	tests := []struct {
		name   string
		pragma litlua.Pragma
		want   string
	}{
		{
			name: "lua_output",
			pragma: litlua.Pragma{
				Output: "config.lua",
			},
			want: "config.litlua.lua",
		},
		{
			name: "litlua_output",
			pragma: litlua.Pragma{
				Output: "config.litlua",
			},
			want: "config.litlua.lua",
		},
		{
			name: "litlua_lua_output",
			pragma: litlua.Pragma{
				Output: "config.litlua.lua",
			},
			want: "config.litlua.lua",
		},
		{
			name: "litlua_lua_output_force",
			pragma: litlua.Pragma{
				Output: "config.litlua.lua",
				Force:  true,
			},
			want: "config.litlua.lua",
		},
		{
			name: "lua_output_force",
			pragma: litlua.Pragma{
				Output: "config.lua",
				Force:  true,
			},
			want: "config.lua",
		},
		{
			name: "invalid_output",
			pragma: litlua.Pragma{
				Output: "config.invalid",
			},
			want: "config.invalid.litlua.lua",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			transformer := NewTransformer(TransformOptions{})
			got := transformer.CleanPragmaOutputExt(tt.pragma)
			if filepath.Clean(got) != filepath.Clean(tt.want) {
				t.Errorf("CleanPragmaOutputExt() = %v, want %v", got, tt.want)
			}
		})
	}

}

func TestCleanShadowOutput(t *testing.T) {
	tests := []struct {
		name  string
		input string
		want  string
	}{
		{
			name:  "litlua_md_input",
			input: "config.litlua.md",
			want:  "config.litlua.lua",
		},
		{
			name:  "md_input",
			input: "config.md",
			want:  "config.md.litlua.lua",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			transformer := NewTransformer(TransformOptions{})
			got := transformer.CleanShadowOutputExt(tt.input)
			if filepath.Clean(got) != filepath.Clean(tt.want) {
				t.Errorf("CleanShadowOutputExt() = %v, want %v", got, tt.want)
			}
		})
	}

}
func TestResolveOutputPath(t *testing.T) {
	tests := []struct {
		name       string
		absSrcPath string
		pragma     litlua.Pragma
		opts       TransformOptions
		want       string
		wantErr    bool
	}{
		{
			name:       "no_pragma_simple",
			absSrcPath: "config.litlua.md",
			pragma:     litlua.Pragma{},
			opts:       TransformOptions{},
			want:       "config.litlua.lua",
		},
		{
			name:       "no_pragma_simple_md",
			absSrcPath: "config.md",
			pragma:     litlua.Pragma{},
			opts:       TransformOptions{},
			want:       "config.litlua.lua",
		},
		{
			name:       "no_pragma_simple_no_litlua_ext",
			absSrcPath: "config.litlua.md",
			pragma:     litlua.Pragma{},
			opts: TransformOptions{
				NoLitLuaOutputExt: true,
			},
			want: "config.lua",
		},
		{
			name:       "no_pragma_with_path",
			absSrcPath: "/home/user/nvim/config.litlua.md",
			pragma:     litlua.Pragma{},
			opts:       TransformOptions{},
			want:       "/home/user/nvim/config.litlua.lua",
		},
		{
			name:       "with_pragma_relative",
			absSrcPath: "config.md",
			pragma: litlua.Pragma{
				Output: "init.lua",
			},
			opts: TransformOptions{},
			want: "init.litlua.lua",
		},
		{
			name:       "with_pragma_and_path",
			absSrcPath: "/home/user/nvim/config.litlua.md",
			pragma: litlua.Pragma{
				Output: "init.lua",
			},
			opts: TransformOptions{},
			want: "/home/user/nvim/init.litlua.lua",
		},
		{
			name:       "different_extension",
			absSrcPath: "config.luadoc",
			pragma:     litlua.Pragma{},
			opts:       TransformOptions{},
			want:       "config.luadoc.litlua.lua",
		},
		{
			name:       "nested_path_no_pragma",
			absSrcPath: "configs/nvim/init.litlua.md",
			pragma:     litlua.Pragma{},
			opts:       TransformOptions{},
			want:       "configs/nvim/init.litlua.lua",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			transformer := NewTransformer(tt.opts)
			got, err := transformer.resolveTransformToAbsPath(tt.absSrcPath, tt.pragma)
			if (err != nil) != tt.wantErr {
				t.Errorf("resolveTransformToAbsPath() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if filepath.Clean(got) != filepath.Clean(tt.want) {
				t.Errorf("resolveTransformToAbsPath() = %v, want %v", got, tt.want)
			}
		})
	}
}
