package transformer

import (
	"bytes"
	"fmt"
	"github.com/jwtly10/litlua"
	"github.com/stretchr/testify/require"
	"os"
	"path/filepath"
	"testing"
)

func TestTransformer(t *testing.T) {
	tests := []struct {
		name      string
		inputFile string
		opts      TransformOptions
		wantErr   string
		validate  func(t *testing.T, outputPath string)
	}{
		{
			name:      "pretty_lua",
			inputFile: "basic.md",
			opts: TransformOptions{
				WriterMode: litlua.ModePretty,
				NoBackup:   true,
			},
			validate: func(t *testing.T, outputPath string) {
				content, err := os.ReadFile(outputPath)
				require.NoError(t, err)

				require.Contains(t, string(content), "Generated by LitLua (https://www.github.com/jwtly10/litlua)")
				require.Contains(t, string(content), "local name = \"Hello World\"\nprint(name)")
				require.Contains(t, string(content), "foo = 1 + 2\nprint(foo)")
				require.Contains(t, string(content), "local a = y\nprint(a)")
				require.Contains(t, string(content), "-- Bar is a function that adds two numbers\n--\n-- @param a number\n--\n-- @param b number\n--\n-- @return number sum of a and b\nBar = function(a, b)\n    return a + b\nend\n\n-- You can go to definition of bar by clicking on it\nprint(Bar(10, 11))\n\n-- try typing B in this print function and see the completion\nprint(...)")
			},
		},
		{
			name:      "shadow_lua",
			inputFile: "basic.md",
			opts: TransformOptions{
				WriterMode: litlua.ModeShadow,
				NoBackup:   true,
			},
			validate: func(t *testing.T, outputPath string) {
				content, err := os.ReadFile(outputPath)
				require.NoError(t, err)

				require.NotContains(t, string(content), "Generated by LitLua (https://www.github.com/jwtly10/litlua)")
				require.Contains(t, string(content), "local name = \"Hello World\"\nprint(name)")
				require.Contains(t, string(content), "foo = 1 + 2\nprint(foo)")
				require.Contains(t, string(content), "local a = y\nprint(a)")
				require.Contains(t, string(content), "-- Bar is a function that adds two numbers\n--\n-- @param a number\n--\n-- @param b number\n--\n-- @return number sum of a and b\nBar = function(a, b)\n    return a + b\nend\n\n-- You can go to definition of bar by clicking on it\nprint(Bar(10, 11))\n\n-- try typing B in this print function and see the completion\nprint(...)")
			},
		},
		{
			name:      "broken_lua_block",
			inputFile: "broken_lua_block.md",
			opts: TransformOptions{
				WriterMode:          litlua.ModePretty,
				NoBackup:            true,
				RequirePragmaOutput: false,
			},
			validate: func(t *testing.T, outputPath string) {
				content, err := os.ReadFile(outputPath)
				require.NoError(t, err)

				require.Contains(t, string(content), "Generated by LitLua (https://www.github.com/jwtly10/litlua)")
				require.Contains(t, string(content), "local name = \"Hello World\"\nprint(name)<!-- @pragma output: compiled.lua -->\n\n# This file is both a real test and an example of the LSP for LitLua\n\nWe have some basic lua blocks here, which you can play around with and see the lsp complain!\n\nThis works... try to break it\n\nlocal name = \"Hello World\"\nprint(name)")
			},
		},
		{
			name:      "with_pragma",
			inputFile: "with_pragma.md",
			opts: TransformOptions{
				WriterMode:          litlua.ModePretty,
				NoBackup:            true,
				RequirePragmaOutput: true,
			},
			validate: func(t *testing.T, outputPath string) {
				content, err := os.ReadFile(outputPath)
				require.NoError(t, err)

				require.Contains(t, string(content), "Generated by LitLua (https://www.github.com/jwtly10/litlua)")
				require.Contains(t, string(content), "local name = \"Hello World\"\nprint(name)")
				require.Contains(t, string(content), "foo = 1 + 2\nprint(foo)")
				require.Contains(t, string(content), "local a = y\nprint(a)")
				require.Contains(t, string(content), "-- Bar is a function that adds two numbers\n--\n-- @param a number\n--\n-- @param b number\n--\n-- @return number sum of a and b\nBar = function(a, b)\n    return a + b\nend\n\n-- You can go to definition of bar by clicking on it\nprint(Bar(10, 11))\n\n-- try typing B in this print function and see the completion\nprint(...)")
			},
		},
		{
			name:      "without_output_pragma",
			inputFile: "without_output_pragma.md",
			opts: TransformOptions{
				WriterMode:          litlua.ModePretty,
				NoBackup:            true,
				RequirePragmaOutput: true,
			},
			validate: func(t *testing.T, outputPath string) {
				content, err := os.ReadFile(outputPath)
				require.NoError(t, err)

				require.Contains(t, string(content), "Generated by LitLua (https://www.github.com/jwtly10/litlua)")
				require.Contains(t, string(content), "local name = \"Hello World\"\nprint(name)")
				require.Contains(t, string(content), "foo = 1 + 2\nprint(foo)")
				require.Contains(t, string(content), "local a = y\nprint(a)")
				require.Contains(t, string(content), "-- Bar is a function that adds two numbers\n--\n-- @param a number\n--\n-- @param b number\n--\n-- @return number sum of a and b\nBar = function(a, b)\n    return a + b\nend\n\n-- You can go to definition of bar by clicking on it\nprint(Bar(10, 11))\n\n-- try typing B in this print function and see the completion\nprint(...)")
			},
			wantErr: "pragma key 'output' is required for transformation",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dir := newTestDir(t)
			defer dir.cleanup()

			testInputDir := filepath.Join("testdata", "transformer")
			input, err := os.ReadFile(filepath.Join(testInputDir, tt.inputFile))
			require.NoError(t, err)

			setupFiles(t, testInputDir, dir)

			transformer := NewTransformer(tt.opts)

			mdPath := filepath.Join(dir.path, tt.inputFile)
			err = os.WriteFile(mdPath, input, 0644)
			require.NoError(t, err)

			src := MarkdownSource{
				Content: bytes.NewReader(input),
				Metadata: litlua.MetaData{
					AbsSource: mdPath,
				},
			}

			if tt.opts.WriterMode == litlua.ModeShadow {
				shadowPath := filepath.Join(dir.path, tt.inputFile+".lua")
				src.Metadata.AbsSource = shadowPath

				outputPath, err := transformer.TransformToPath(src, shadowPath)
				if tt.wantErr != "" {
					if err == nil {
						t.Fatalf("expected error: %s, got nil", tt.wantErr)
					}
					require.Equal(t, tt.wantErr, err.Error())
					return
				}
				require.NoError(t, err)

				fmt.Printf("output path: %s", outputPath)

				tt.validate(t, outputPath)
				return
			}

			outputPath, err := transformer.Transform(src)
			if tt.wantErr != "" {
				if err == nil {
					t.Fatalf("expected error: %s, got nil", tt.wantErr)
				}
				require.Equal(t, tt.wantErr, err.Error())
				return
			}
			require.NoError(t, err)

			fmt.Printf("output path: %s", outputPath)

			tt.validate(t, outputPath)
		})
	}
}

func TestResolveOutputPath(t *testing.T) {
	tests := []struct {
		name       string
		absSrcPath string
		pragma     litlua.Pragma
		want       string
		wantErr    bool
	}{
		{
			name:       "no_pragma_simple",
			absSrcPath: "config.md",
			pragma:     litlua.Pragma{},
			want:       "config.lua",
		},
		{
			name:       "no_pragma_with_path",
			absSrcPath: "/home/user/nvim/config.md",
			pragma:     litlua.Pragma{},
			want:       "/home/user/nvim/config.lua",
		},
		{
			name:       "with_pragma_relative",
			absSrcPath: "config.md",
			pragma: litlua.Pragma{
				Output: "init.lua",
			},
			want: "init.lua",
		},
		{
			name:       "with_pragma_and_path",
			absSrcPath: "/home/user/nvim/config.md",
			pragma: litlua.Pragma{
				Output: "init.lua",
			},
			want: "/home/user/nvim/init.lua",
		},
		{
			name:       "different_extension",
			absSrcPath: "config.luadoc",
			pragma:     litlua.Pragma{},
			want:       "config.lua",
		},
		{
			name:       "nested_path_no_pragma",
			absSrcPath: "configs/nvim/init.md",
			pragma:     litlua.Pragma{},
			want:       "configs/nvim/init.lua",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := resolveTransformToAbsPath(tt.absSrcPath, tt.pragma)
			if (err != nil) != tt.wantErr {
				t.Errorf("resolveTransformToAbsPath() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if filepath.Clean(got) != filepath.Clean(tt.want) {
				t.Errorf("resolveTransformToAbsPath() = %v, want %v", got, tt.want)
			}
		})
	}
}
