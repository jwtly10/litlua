package litlua

import (
	"fmt"
	"io"
	"log/slog"
	"strings"
	"time"
)

type WriteMode int

const (
	// ModePretty Writes with headers and formatting
	ModePretty WriteMode = iota
	// ModeShadow Writes preserving line positions for LSP
	ModeShadow
)

// Writer writes a parsed Markdown Document to the configured output writer
type Writer struct {
	mode WriteMode
}

// NewWriter creates a new Writer with the specified write mode [WriteMode]
func NewWriter(mode WriteMode) *Writer {
	return &Writer{
		mode: mode,
	}
}

func (w *Writer) Write(doc *Document, out io.Writer, version string, now time.Time) error {
	switch w.mode {
	case ModePretty:
		return w.writePretty(doc, out, version, now)
	case ModeShadow:
		return w.writeShadow(doc, out)
	}
	return fmt.Errorf("invalid write mode")
}

// writePretty writes a parsed Markdown Document to the configured output writer
func (w *Writer) writePretty(doc *Document, out io.Writer, version string, now time.Time) error {
	header := fmt.Sprintf(`-- Generated by LitLua (https://www.github.com/jwtly10/litlua) %s
-- Source: %s
-- Generated: %s

-- WARNING: This is an auto-generated file.
-- Do not modify this file directly as changes will be overwritten on next compilation.
-- Instead, modify the source markdown file and recompile.

`, version, doc.Metadata.Source, now.Format(time.RFC3339))

	if _, err := fmt.Fprint(out, header); err != nil {
		return fmt.Errorf("writing header: %w", err)
	}

	for _, block := range doc.Blocks {
		if _, err := fmt.Fprintf(out, "%s\n", block.Code); err != nil {
			return fmt.Errorf("writing block: %w", err)
		}
	}

	slog.Debug("wrote document to output", "blocks", len(doc.Blocks), "source", doc.Metadata.Source, "output", doc.Pragmas.Output)

	return nil

}

// writeShadow generates a shadow Lua file preserving original line numbers
func (w *Writer) writeShadow(doc *Document, out io.Writer) error {
	var lines []string

	maxLine := doc.Blocks[len(doc.Blocks)-1].Position.EndLine
	lines = make([]string, maxLine)

	for i := range lines {
		lines[i] = ""
	}

	slog.Debug("writing document to LSP shadow file", "blocks", len(doc.Blocks), "last_line", maxLine, "source", doc.Metadata.Source)

	for _, block := range doc.Blocks {
		blockLines := strings.Split(block.Code, "\n")

		startLine := block.Position.StartLine

		for i, line := range blockLines {
			actualIndex := startLine + i - 1 // arrays are 0-indexed, but file lines are 1-indexed
			if lines[actualIndex] != "" {
				return fmt.Errorf("line %d already contains code", startLine+i)
			}

			slog.Debug("writing block line", "line", startLine+i, "code", line)
			lines[actualIndex] = line
		}
	}

	for _, line := range lines {
		if _, err := fmt.Fprintln(out, line); err != nil {
			return fmt.Errorf("writing line: %w", err)
		}
	}

	return nil

}
